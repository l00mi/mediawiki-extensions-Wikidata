<?php

namespace WikibaseQuality\ConstraintReport\Maintenance;

use Wikibase\DataModel\Entity\PropertyId;
use WikibaseQuality\ConstraintReport\Constraint;
use WikibaseQuality\ConstraintReport\ConstraintReportFactory;
use WikibaseQuality\ConstraintReport\ConstraintRepository;

$basePath = getenv( "MW_INSTALL_PATH" ) !== false
	? getenv( "MW_INSTALL_PATH" ) : __DIR__ . "/../../..";

require_once $basePath . "/maintenance/Maintenance.php";

/**
 * @package WikibaseQuality\ConstraintReport\Maintenance
 *
 * Fills constraint table with constraints given in a csv file passed to this.
 * Should be done once a week to keep constraint table up to date.
 *
 * csv-file is generated by:
 * https://github.com/WikidataQuality/ConstraintsFromTemplates/blob/master/csvScriptBuilder.py
 */
class UpdateConstraintsTable extends \Maintenance {

	public function __construct() {
		parent::__construct();

		$this->addDescription( "Reads csv file and writes its contents into constraints table" );
		$this->addOption(
			'csv-file',
			'csv file that contains constraints parsed from the property talk pages.',
			true,
			true
		);

		$this->setBatchSize( 1000 );
	}

	public function execute(){
		$csvFile = fopen( $this->getOption( 'csv-file' ), 'rb' );
		if( !$csvFile ) {
			$this->error( "Error while opening csv-file", 1 );
		}

		$constraintRepo = ConstraintReportFactory::getDefaultInstance()->getConstraintRepository();
		$constraintRepo->deleteAll( $this->mBatchSize );
		$this->insertValues( $constraintRepo, $csvFile );
		fclose( $csvFile );
	}

	private function insertValues( ConstraintRepository $constraintRepo, $csvFile ) {
		$i = 0;
		$db = wfGetDB( DB_MASTER );
		$accumulator = array();

		while ( true ) {
			$data = fgetcsv( $csvFile );
			if ( $data === false || ++$i % $this->mBatchSize === 0 ) {
				$constraintRepo->insertBatch( $accumulator );

				$db->commit( __METHOD__, 'flush' );
				wfGetLBFactory()->waitForReplication();

				if ( !$this->isQuiet() ) {
					$this->output( "\r\033[K" );
					$this->output( "$i rows inserted" );
				}

				$accumulator = array();

				if ( $data === false ) {
					break;
				}
			}

			list( $constraintId, $numericPropertyId, $constraintTypeQid, $params ) = $data;
			$constraintParameters = (array) json_decode( $params );

			$accumulator[] = new Constraint(
				$constraintId,
				PropertyId::newFromNumber( $numericPropertyId ),
				$constraintTypeQid,
				$constraintParameters
			);
		}
	}

}

// @codeCoverageIgnoreStart
$maintClass = UpdateConstraintsTable::class;
require_once RUN_MAINTENANCE_IF_MAIN;
// @codeCoverageIgnoreEnd
